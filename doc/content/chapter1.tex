
\chapter{Initial considerations}

This chapter discusses the basics of KamilaLisp. Throughout this book, the author will use the KamilaLisp interpreter to check and execute the declarations of a program one by one. The emphasis is put on list processing and mathematical functions to form an elementary understanding of the language.

\section{Programs and variables}

A KamilaLisp program is a sequence of declarations, which are executed in the order they are given. The first program presented in this book is shown below:

\begin{Verbatim}
    --> def a (+ (* 2 3) 2)
    8
    --> def b (* 5 a)
    40
\end{Verbatim}

The program consists of two declarations. The first declaration binds the identifier a to the integer 8, and the second declaration binds the identifier b to the integer 40, which follows from the intuitive understanding of the arithmetic operations. To the reader not accustomed to Lisp-like syntax, every element of the syntax tree that would otherwise be implicitly grouped by a language with usual arithmetical precedence rules is explicitly grouped by parentheses to form a list. The resulting values of variables can be determined as follows:

\begin{Verbatim}
    --> ?a
    8
    --> ?b
    40
\end{Verbatim}

The question mark is a sign for the KamilaLisp interpreter not to evaluate the entire input as an expression but rather, to query the value of the value it refers to.

Every list besides the empty list (usually written as \verb|()| or alternatively \verb|nil|) has a \textit{head} defined as the first element of it. When a Lisp program is evaluated, the \textit{head} of the current list is assumed to be a callable value, while the rest of the list (also called the \textit{tail}) is assumed to be a list of arguments.

Because the list of arguments to a function (the \textit{tail}) is evaluated before its applied to the \textit{head}, a perceptive reader could point out a potential issue - \textit{How to introduce list literals in the code}? This question is indeed well-founded, since the list literal would be evaluated in order to pass it parameter to some callable object, hence the tail of the literal would be applied to its head, thus behaving undesirably and almost certainly raising an error. Every Lisp dialect addresses this issue in the same way using the quoting mechanism. Simply put, the quote prevents a list from being evaluated. To observe this behaviour, introduce two more functions called \verb|car| and \verb|cdr| to obtain respectively the \textit{head} and \textit{tail} of a list:

\begin{Verbatim}
    --> car '(1 2 3)
    1
    --> cdr '(1 2 3)
    (2 3)
\end{Verbatim}

This may alert the observant reader once again - \textit{What if I want to create a list out of a set of expressions}? This question very relevant because if the quote stops a form from being evaluated, then surely the expressions inside of it will stay untouched too. The answer is simple - use the \verb|tie| function as follows:

\begin{Verbatim}
    --> tie 1 2 3
    (1 2 3)
    --> tie (+ 2 2) (/ 6 3) (+ 2 3)
    (4 2 5)
\end{Verbatim}

KamilaLisp follows scoping rules familiar to the reader from other programming languages, such as Scheme or C++ - \textit{static scoping} (also called \textit{lexical scoping}), where an attempt is initially made to resolve a variable in the current scope. If this approach fails, the variable is resolved in the scope of its lexical ancestors until either the interpreter finds an environment where the variable is bound, or raises an error regarding an unbound variable. Additionally, variables may be \textit{shadowed}, as demonstrated below:

\begin{Verbatim}
    --> def my-list '(1 2 3)
    (1 2 3)
    --> car my-list
    1
    --> def my-list (cdr my-list)
    (2 3)
    --> car my-list
    2
\end{Verbatim}

However, it is not possible to shadow pre-defined variables and functions in the global scope:

\begin{Verbatim}
    --> def car 5
    RuntimeException thrown in thread 1dbd16a6:
            def can not shadow or redefine built-in bindings.
        at entity def  1:1
        at def primitive function
\end{Verbatim}

To fully exercise lexical scoping, the language needs to provide means of binding names inside a specific block of code (unlike \textit{def} which binds names in the global scope). This can be accomplished in a variety of ways, the most straightforward one being the \textit{let} construct. The \textit{let} construct binds a list of name/value pairs and evaluates the body of the construct in the context of the newly created environment. The syntax of the \textit{let} construct is demonstrated by the following example:

\begin{Verbatim}
    --> def a 5
    5
    --> def b 6
    6
    --> + a b
    11
    --> let ((a 10) (b 15)) (+ a b)
    25
\end{Verbatim}

\section{Functions and lambda expressions}

Functions are the core component of KamilaLisp. They are first-class objects, meaning they can be passed as arguments to other functions, returned from functions and bound to names. The syntax of a function declaration is as follows:

\begin{Verbatim}
    --> defun square (x) (* x x)
    (λ x . (* x x))
\end{Verbatim}

The function that has just been declared is called \verb|square| and takes one argument called \verb|x|. The body of the function is the expression \verb|* x x|. The function returns the value of its expression in an environment where its arguments are bounded, which in this particular scenario is naturally the square of the argument. Notice that when defining a monadic function, a pair of parentheses around its only argument's name can be omitted for brevity:

\begin{Verbatim}
    --> defun square x (* x x)
    (λ x . (* x x))
\end{Verbatim}

Since \verb|square| is now bound in the global scope, it can be applied to an argument. The code below binds the name \verb|a| to the result of the application of the number 5 to the function \verb|square|:

\begin{Verbatim}
    --> def a (square 5)
    25
\end{Verbatim}

Functions do not need to be named. They can be introduced in the code \textit{anonymously} using the \textit{lambda} construct, which opens up many new possibilities for structuring code. For example, the declaration of the function \verb|square| can be rewritten as follows:

\begin{Verbatim}
    --> def square (lambda x (* x x))
    (λ x . (* x x))
\end{Verbatim}

Furthermore, multivariate lambda expressions can serve as a substitute for the \textit{let} construct:

\begin{Verbatim}
    --> let ((a 10) (b 15)) (+ a b)
    25
    --> (lambda (a b) (+ a b)) 10 15
    25
\end{Verbatim}

Since functions are first-class in KamilaLisp, it is also possible to return them from functions and take them as arguments. The following example demonstrates these programming techniques using the \textit{lambda} construct:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
    --> ; Returns a string explaining the value of a function at point.
    --> defun explain (f x) (str:format "The value of f(x) for x={?x} is {f x}")
    (λ f x . (str:format "The value of f(x) for x={?x} is {f x}"))
    --> explain square 4.5
    The value of f(x) for x=4.5 is 20.25
\end{Verbatim}

When implementing complex functions, it is often of particular interest to keep the partial results obtained during the execution of the function. This is achieved by cascading the \textit{let} construct or using the \textit{let-seq} construct. The following examples implement a function that raises its only argument to the eighth power\footnote{Many reimplementations of common built-in functions mentioned in the book that are present in KamilaLisp are rather suboptimal and demonstrated only for the sake of completeness. The programmer is urged to use the optimised predefined routines when possible instead.}:

\begin{Verbatim}
    --> defun p8 x (let-seq
    ...   (def y (* x x))
    ...   (def z (* y y))
    ...   (* z z))
    (λ x . (let-seq (def y (* x x)) (def z (* y y)) (* z z)))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x))) (let ((z (* y y))) (* z z)))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x)) (z (* y y))) (* z z))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
\end{Verbatim}

Notice that despite using \verb|def|, \verb|defun|, etc..., the \textit{let-seq} construct does not create any new bindings in the global scope - the bindings are always local to the block.

When a function is called, the \textit{call stack} is modified in the process. The call stack is a data structure implemented inside of the interpreter that keeps track of the lambda expressions that are currently being executed. Application of a lambda function forces creation of a new \textit{stack frame} which is subsequently pushed onto the stack. When the function returns, the stack frame is popped from the stack - this way, the interpreter knows where to return to after the function yields a value. When an exception is raised, the interpreter will present the user with a \textit{stack trace}, which is a list of functions that were executed before the exception was raised, for example:

\begin{Verbatim}
    --> defun f x (/ 1 0) ; Oops! Division by zero!
    (λ x . (/ 1 0))
    --> defun g x (f x)
    (λ x . (f x))
    --> defun h x (g x)
    (λ x . (g x))
    --> h 10
    ArithmeticException thrown in thread 5e82df6a:
        Division by zero
    at entity h  1:1
    at (λ x . (g x))  1:9
    at entity g  1:12
    at (λ x . (f x))  1:9
    at entity f  1:12
    at (λ x . (/ 1 ...))  1:9
    at entity /  1:12
    at / primitive function
\end{Verbatim}

\section{Conditional expressions and comparisons}

The comparison operators in KamilaLisp do not differ significantly from the ones present in other, perhaps more orthodox programming languages (such as C). It is worth noting that scalar\footnote{Operating on scalar values, i.e. not vector, matrix or general array values.} equality is checked using the \verb|=| function, inequality is checked for using the \verb|/=| function, while the \verb|<=>| function is the so-called \textit{three way comparison} operator\footnote{Also called the \textit{spaceship} operator.}, which returns -1, 0 or 1 respectively if the first argument is less than, equal to, or greater than the second argument.

KamilaLisp provides a number of conditional expressions used to control the flow of execution. The most basic one is the \textit{if} construct which takes three arguments - a condition, an expression to be evaluated if the condition is true, and an expression to be evaluated if the condition is false. The syntax of the \textit{if} construct is demonstrated by the following example:

\begin{Verbatim}
    --> defun my-abs x (if (< x 0) (- x) x)
    (λ x . (if (< x 0) (- x) x))
    --> my-abs -5
    5
    --> my-abs 5
    5
    --> my-abs 0
    0
\end{Verbatim}

The \textit{if} construct is a special case of the more general \textit{cond}, which takes a list of pairs of conditions and expressions. The first condition that evaluates to a truthy value is used to evaluate the corresponding expression. The syntax of the \textit{cond} construct is demonstrated by the following reimplementation of the three-way comparison operator:

\begin{Verbatim}
    --> defun compare (x y) (cond ((< x y) -1) ((> x y) 1) (0))
    (λ x y . (cond ((< x y) -1) ((> x y) 1) (0)))
    --> compare 5 10
    -1
    --> compare 10 5
    1
    --> compare 5 5
    0
\end{Verbatim}

\section{Recursive functions}

Recursion is a powerful technique extensively used in functional programming. Its role in KamilaLisp is admittedly not as extensive as in other functional programming languages, since the language provides a number of other often more wieldy techniques for solving the same problems (e.g. using array programming), however it is still worth mentioning that KamilaLisp provides a number of tools for writing recursive functions.

The following function implements the \textit{factorial} function in a recursive manner:

\begin{Verbatim}
    --> defun factorial (n) (if (= n 0) 1 (* n (factorial (- n 1))))
    (λ n . (if (= n 0) 1 (* n (factorial (- n 1)))))
    --> factorial 5
    120
\end{Verbatim}

Since KamilaLisp supports arbitrary precision numerical computation, the factorial function can be applied to arbitrarily large numbers. However, at some point this function will \textit{overflow its call stack}, meaning that the number of recursive calls will exceed the maximum call stack size. This is a common problem with recursive functions and it can be solved by using \textit{tail recursion}. Tail recursion is a special case of recursion, where the recursive call is the last expression in the function body. In this case, the stack frame of the current function can be reused for the recursive call, hence the stack will cease to grow uncontrollably. To make use of this technique, the factorial function needs to be altered in a way that the recursive call is the last expression in the function body:

\begin{Verbatim}
    --> defun factorial (n) (let-seq 
    ...   (defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc))))
    ...   (f' n 1))
    --> factorial 5
    120
\end{Verbatim}

The factorial function defines a helper function that has an accumulator argument, which is used to store the intermediate results of the computation. The helper function is called recursively and the accumulator argument is updated with the result of the multiplication. The \textit{let-seq} construct is used to define the helper function, so that it is not visible outside the factorial function. There is one more step to make this function tail-recursive: replace the self-referential call in the helper function:

\begin{Verbatim}
    --> defun factorial (n) (let-seq
    ...   (defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc))))
    ...   (f' n 1))
    --> factorial 5
    120
\end{Verbatim}

The self-referential call was replaced by \verb|&0| which is a reference to the current function. This is a special case of the \verb|&| operator, which is used to refer to functions by nesting level in the source code, akin to de Bruijn indices. The \verb|&0| operator refers to the current function, \verb|&1| refers to the function (anonymous or named) that is the lexical ancestor the current function, and so on. This way, the factorial function no longer raises an error when applied to large numbers, since the stack does not grow beyond the maximum size:

\begin{Verbatim}
    --> factorial 1000
    402387260077093773543702433923003985719374864210714
    632543799910429938512398629020592044208486969404800
    ; [...]
    000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000
\end{Verbatim}

Another closely related function to the factorial function that can be implemented using tail recursion is the power function. The following expression implements the power function in a simple recursive manner:

\begin{Verbatim}
    --> defun power (x n) (if (= n 0) 1 (* x (power x (- n 1))))
    (λ x n . (if (= n 0) 1 (* x (power x (- n 1)))))
    --> power 2 10
    1024
\end{Verbatim}

Once again, the problem is that the stack will overflow when the power function is applied to large numbers. To prevent this and speed up the computation, the power function needs to be first transformed so that the recursive call is the last expression in the function body. Consider the following \textit{trace} of the power function applied to the arguments \verb|2| and \verb|4|:

\begin{Verbatim}
    --> power 2 4
    (* 2 (power 2 3))
    (* 2 (* 2 (power 2 2)))
    (* 2 (* 2 (* 2 (power 2 1))))
    (* 2 (* 2 (* 2 (* 2 (power 2 0)))))
    (* 2 (* 2 (* 2 2)))
    (* 2 (* 2 4))
    (* 2 8)
    16
\end{Verbatim}

After transforming the function to use an accumulator:

\begin{Verbatim}
    --> defun power (x n) (let-seq
    ...   (defun f' (x n acc) (if
    ...       (= n 0)
    ...       acc
    ...       (f' x (- n 1) (* x acc))))
    ...   (f' x n 1))
\end{Verbatim}

When this implementation of the power function is applied to the same arguments as before, the following trace is produced:

\begin{Verbatim}
    --> power 2 4
    (f' 2 4 1)
    (f' 2 3 2)
    (f' 2 2 4)
    (f' 2 1 8)
    (f' 2 0 16)
    16
\end{Verbatim}

Notice, that the size of the expression \textit{does not grow}, hence the function could in theory be rewritten as a simple loop with a constant stack usage requirement - a concept more familiar from imperative programming languages such as C or C++. The final improvement that needs to be applied is actually coaxing the interpreter to perform tail call optimisation using the self-referential call \verb|&0|:

\begin{Verbatim}
    --> defun power (x n) ((
    ...    lambda (x n acc) (
    ...        if (= n 0) acc
    ...            (&0 x (- n 1) (* x acc)))) x n 1)
    --> power 2 4
    16
\end{Verbatim}

\section{Function composition}

Function composition is a a common core concept in functional programming languages, an emphasis on which is placed in KamilaLisp. Using the \verb|@| operator, it is possible to compose two or more functions into a single function. An example follows:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> f 2
    4
    --> g 2
    3
    --> f@g 2
    6
\end{Verbatim}

The usefulness of function composition may be challenging to appreciate at first. In the end, \verb|f@g x| $\Leftrightarrow$ \verb|f (g x)|, however, the function returned by the \verb|@| operator does not have to be immediately applied - it can be bound to a name and used later. Without the composition operator, it would be necessary to introduce a \textit{lambda} to achieve the same result as \verb|f@g| - that is, \verb|lambda x (f (g x))|. The difference between manually composing two functions to create a new function and using the \verb|@| operator is how they treat arguments\footnote{Function composition performed using the \verb|@| operator does not require creating a new stack frame for the lambda function.}. The \verb|@| operator variant of the same expression does not refer to the arguments of the composed functions (and thus does not manually relay an indeterminate amount of them to the innermost function), creating the basic building block for \textit{point-free programming}.

Of course, it is possible to compose arbitrarily many functions by using the \verb|@| operator multiple times. The following example demonstrates the composition of three functions:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> defun h x (- x 3)
    (λ x . (- x 3))
    --> f@g@h 2
    0
\end{Verbatim}

Another form of function composition notoriously used in the APL family of programming languages is the so-called \textit{fork} (the \mu-recursive composition operator). Generally speaking, it is sometimes of special interest to preprocess the arguments using different functions (\textit{reductees}), and then funnel the results into a single function (\textit{reductor}). For instance, the arithmetic mean is defined as the quotient (\textit{reductor}) of the sum and length of a list (\textit{reductees}), while a palindrome is defined as a string for which the equality (\textit{reductor}) between it and its reverse (\textit{reductees}) holds.

To implement a sum function using a fork, it is necessary to define a function that sums the list beforehand using the \verb|tally| function which returns the length of a list. A non-zero value is considered truthy, hence the following definition of the \textit{sum} function:

\begin{Verbatim}
    --> defun sum (l) (if (tally l) (+ (car l) (sum (cdr l))) 0)
    (λ l . (if (tally l) (+ (car l) (sum (cdr l))) 0))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

There are many alternative ways to implement it. One problem the reader may stumble upon is \verb|= 'nil 'nil| returning \verb|'nil|. This behaviour is reasoned by the fact that equality \textit{vectorises} over lists\footnote{A more specific way to phrase it would be to say that \verb|=| is a \textit{pervasive function}.}, meaning that equality is tested element-wise. To determine structural equality, it is advised to use the \verb|same| function. The following example demonstrates this behaviour:

\begin{Verbatim}
    --> = '(1 2 3) '(1 2 4)
    (1 1 0)
    --> same '(1 2 3) '(1 2 4)
    0
    --> same '(1 2 3) '(1 2 3)
    0
\end{Verbatim}

Hence arguing for a simpler implementation of the \textit{sum} function:

\begin{Verbatim}
    --> defun sum (l) (if (same l '()) 0 (+ (car l) (sum (cdr l))))
    (λ l . (if (same l '()) 0 (+ (car l) (sum (cdr l)))))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

The arithmetic mean function is thusly introduced as follows:

\begin{Verbatim}
    --> [/ sum tally] '(1 6 2 3 4)
    3.2
\end{Verbatim}

Naturally, it could also be bound to a name without applying the fork instantaneously:

\begin{Verbatim}
    --> def avg [/ sum tally]
    [/ sum tally]
    --> avg '(1 6 2 3 4)
    3.2
\end{Verbatim}

The key merits of point-free programming are:

\begin{itemize}
    \item The code is more concise.
    \item The code is often more readable.
    \item The code is faster, because there is no need to allocate a stack frame.
    \item The code does not need to bind any names.
\end{itemize}

The lack of argument naming gives the point-free paradigm a reputation of being obtuse, hence the humorously used epithet "pointless style"\footnote{http://hdl.handle.net/1822/2869}. However, the point-free paradigm is not necessarily obscure. In fact, it is often more readable than the equivalent imperative code and favoured by many languages, such as Haskell, APL, J, PostScript, Forth, Factor, jq and the Unix shell\footnote{The pipe operator is essentially point-free function composition. The Unix shell has more interesting properties from a category theoretic perspective, due to its extensive use of monads. The pipe operator is an implementation of \verb|bind|, \verb|cat| is in reality monadic \verb|return|. Moreover, a pair of these operations, adding \verb|<| and \verb|>|, satisfy the monadic laws - \verb$cat f | cmd$ is the same as \verb|cmd <f| (left-hand identity); \verb$cmd | cat$ is the same as \verb|cmd| (right-hand identity); \verb$c1 | (c2 | c3)$ is the same as \verb$(c1 | c2) | c3$.}.

\section{Partial application and \texorpdfstring{$\mu$}{mu}-recursive functions}

Many functional programming languages such as OCaml and Haskell automatically \textit{curry} functions by default, that is, allow applying functions to fewer arguments than they are defined to take. This is a useful feature, since it allows for the creation of new functions by binding some of the arguments of a function to a value. This mechanism is called \textit{partial application}. KamilaLisp supports partial application of functions but it does not happen by default, as unlike OCaml and Haskell, KamilaLisp supports variadic functions. Recall the following example given earlier in the book:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
\end{Verbatim}

Using partial application, the example can be rewritten as follows:

\begin{Verbatim}
    --> defun add-x n $(+ n)
    (λ n . $(+ n))
    --> def add-5 (add-x 5)
    $(+ n)
    --> add-5 6
    11
\end{Verbatim}

Partial application is particularly useful in conjunction with various kinds of function composition, as it allows for the vast majority of functions that are defined in terms of other functions to be defined in a point-free manner. Another valuable example would be a function that returns the remainder of a number when divided by two.

\begin{Verbatim}
    --> defun mod-2 (n) (mod n 2)
    (λ n . (mod n 2))
    --> mod-2 10
    0
    --> mod-2 11
    1
\end{Verbatim}

It is not immediately clear how to define this function in a point-free manner, since partial application will apply the arguments in order as given, and the argument that needs to be partially applied here is actually the \textit{second} argument to \verb|mod|. This problem can be solved in a two ways - the first one is to use the commute operator \verb|^| which reverses the argument order to a function:

\begin{Verbatim}
    --> def mod-2 $(^mod 2)
    $['^mod, '2]
    --> mod-2 5
    1
    --> mod-2 6
    0
\end{Verbatim}

Another, perhaps more elegant solution is to use partial application placeholders:

\begin{Verbatim}
    --> def mod-2 $(mod _ 2)
    $['mod, _, '2]
    --> mod-2 5
    1
    --> mod-2 6
    0
\end{Verbatim}

This way, the \verb|_| placeholder indicates that the first argument given to the resulting function should be applied in its place. The placeholder can be used multiple times and it is required that all placeholder slots are filled when applying the already partially applied function.

Variadic functions are functions that take an arbitrary number of arguments. \verb|+| is a good example of a variadic function, since when applied to more than two arguments it just sums all of them:

\begin{Verbatim}
    --> + 1 2 3 4 5
    15
\end{Verbatim}

It is possible to define custom variadic functions in KamilaLisp using special argument syntax. To recall, \verb|lambda (x y) (code)| takes two arguments - \textit{x} and \textit{y}. This function can be made variadic by prepending the \textit{last argument} with an ellipsis - \verb|lambda (x ...xs) (code)|. The last argument will be bound to a list of all the remaining arguments. This has an interesting property: while the aforementioned function takes \textit{at least} one argument (because \verb|...xs| can be empty), it can be modified to take any amount of arguments, even zero - \verb|lambda ...xs (code)|. To demonstrate this behaviour, the following function will obtain the arithmetic average of all its arguments, but will refuse to be called with zero arguments:

\begin{Verbatim}
    --> defun avg (x ...xs) (/ (+ x (sum ...xs)) (+ 1 (tally ...xs)))
    (λ x ...xs . (/ (+ x (sum ...xs)) (+ 1 (tally ...xs))))
    --> avg 1 6 2 3 4
    3.2
    --> avg 5
    5
    --> avg
    TypeError thrown in thread 15eb5ee5:
            Expected at least 1 arguments to `(λ x ...xs . (/ (+ x ...) ...))'.
        at entity avg  1:1
        at (λ x ...xs . (/ (+ x (sum ...xs)) ...))  1:11
\end{Verbatim}

Equipped with the power of variadic functions and recursion, the next natural step is to define $\mu$-recursive functions. Consider the following \textit{basic} $\mu$-recursive functions:

\begin{itemize}
    \item For all natural numbers $i, k$ where $0 \le i \le k$, the projection function (sometimes also called the identity function when $i=0$) is defined as $P_i^k(x_0, \dots, x_k)=x_i$. The projection function is a built-in operator in KamilaLisp, where \verb|#a| is equivalent to $P_a^k$.
    \item For each natural $n$ and $k$, the constant function $C_n^k$ is defined as $C_n^k(x_0, \dots, x_k) = x_n$. This is easily implemented using the previously discussed projection function as \verb|$(#0 n)|.
    \item For each natural $n$, the successor function $S_n$ is defined as $S_n(x) = x + 1$. This is easily implemented using just partial application - \verb|$(+ 1)|.
\end{itemize}

The $\mu$-recursive composition operator (also called the substitution operator) defined for an $m$-ary function $h(x_0, \dots, x_m)$ and exactly $m$ $n$-ary functions $g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n)$ as $h\circ(g_0, \dots, g_m) = f$ where $f(x_0, \dots, x_n) = h(g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n))$. This definition is essentially equivalent to KamilaLisp \textit{forks}\footnote{A general version of APL 3-trains; https://aplwiki.com/wiki/Train\#3-trains} - \verb|[h g_0 ... g_m] x_0 ... x_k|.

The $\mu$-recursive primitive recursion operator $\rho(g,h)=f$ for $k$-ary function $g(x_0,\dots,x_k)$, $k+2$-ary function $h(y,z,x_0,\dots,x_k)$ and $k+1$-ary function $f$ yields the following piecewise function:

\begin{equation*}
f(a,x_0,\dots,x_k)=
    \begin{cases}
        g(x_0,\dots,x_k) & \text{if } x = 0\\
        h(a-1,f(a,x_0,\dots,x_k),x_0,\dots,x_k) & \text{if } x \ne 0
    \end{cases}
\end{equation*}

The KamilaLisp implementation of this concept is slightly more involved, requiring the \verb|lift| function to apply a function on a existing variadic parameter pack:

\begin{Verbatim}
    --> defun mu-prim-rec (g h) (
    ...    lambda (a ...xs) (
    ...        if (= a 0)
    ...            (lift g ...xs)
    ...            (lift $(h (- a 1) (lift $(mu-prim-rec g h) ...xs)) ...xs)))
\end{Verbatim}

The $\mu$-recursive \textit{minimization} operator is less demanding to implement. Intuitively, minimisation seeks, beginning the search from 0 and proceeding upwards, the smallest argument that causes the function to return zero; if there is no such argument, of if one encounters an argument for which f is not defined, then the search never terminates, and is not defined for the argument.

\begin{Verbatim}
    --> defun mu-min f (lambda ...xs (let-seq
    ...    (defun mu-min-iter i (if (lift f ...xs) (&0 (S i)) i))
    ...    (mu-min-iter 0)))
\end{Verbatim}

\section{Iteration}

Given a function $f$, the $n$-fold application of $f$ to $x$ is usually denoted in mathematics as $f^n(x)$. For instance, $f^0(x) = x$, $f^1(x) = f(x)$, and $f^2(x) = f(f(x))$. More generally, a recursive relation can be defined as $f^k(x) = f(f^{k-1}(x))$ for $k \ge 1$. Given \textit{an iteration} of a function $f^n(x)$, the function $f$ is called the \textit{step function}, $n$ is called the order of iteration and $x$ is called the \textit{starting value}. In KamilaLisp, iteration is introduced using the \verb|while| higher order function which, in the presently most useful form to the mathematical definition, takes three arguments - the starting value, the order of iteration and the step function.

Consider the successor function \verb|defun s x (+ x 1)|. To provide a basic example, addition of two numbers \verb|+ a b| can be implemented as an iteration of order $b$ of the successor function \verb|s| with the initial value $a$:

\begin{Verbatim}
    --> defun add (a b) (while a b $(+ 1))
    (λ a b . (while a b $(+ 1)))
    --> add 3 4
    7
\end{Verbatim}

Recall the power function and its previously discussed, tail-recursive definition:

\begin{Verbatim}
    --> defun power (x n) ((
    ...    lambda (x n acc) (if (= n 0) acc (&0 x (- n 1) (* x acc)))) x n 1)
    (λ x n . ((λ (x n acc) (if (= n 0) acc (&0/syn x (- n 1) (* x acc)))) x n 1))
\end{Verbatim}

Since tail recursion is essentially equivalent to iteration, the power function may be implemented as an iteration of order $n-1$ of the multiplication function \verb|*| with the initial value $x$:

\begin{Verbatim}
    --> defun power (x n) (while x (- n 1) $(* x))
    (λ x n . (while x (- n 1) $(* x)))
    --> power 2 4
    16
\end{Verbatim}

Iteration using \verb|while| and other higher order functions is described later on in the book. As a tool, iteration is more suitable to certain problems over recursive (functional) or array programming approaches\footnote{For instance, computing the \textit{Convex Hull} using the Graham scan algorithm, which has better asymptotic complexity than the more naive Jarvis scan as easily implemented in array fashion}.

Of course, iteration with a fixed number of steps is the simplest form of iteration that covers many usages of the \verb|for| loop from other more orthodox languages, such as C. However, iteration is often conditional and depends on some particular predicate. Consider the Collatz conjecture, one of the most famous unsolved problems in mathematics. The conjecture asks whether iterating this function as many times as needed will eventually reach the number 1:

\begin{equation*}
    f(n)={\begin{cases}{\frac {n}{2}}&{\text{if }}n\equiv 0{\pmod {2}}\\[4px]3n+1&{\text{if }}n\equiv 1{\pmod {2}}.\end{cases}}
\end{equation*}

Providing a formal proof of the Collatz conjecture is beyond the scope of this book, but KamilaLisp makes it easy to test the conjecture for a finite set of numbers\footnote{Even though the Collatz conjecture has been proven using computers for extremely large values of $n$, this is not enough evidence to claim that the Collatz function is likely true - consider the Polyá conjecture, for which the initial \textit{disproof by counterexample} quoted a number estimated to be around $n = 1.845 \times 10^{361}$}. Start by implementing the function $f$ in code and then use it in a recursive approach and a tail-recursive approach:

\begin{Verbatim}
    --> defun collatz (n) (if (= (mod n 2) 0) (/ n 2) (+ (* 3 n) 1))
    (λ n . (if (= (mod n 2) 0) (/ n 2) (+ (* 3 n) 1)))
    --> defun collatz-rec (n) (if (= n 1) 1 (collatz-rec (collatz n)))
    (λ n . (if (= n 1) 1 (collatz-iter (collatz n))))
    --> defun collatz-tail (n) (if (= n 1) 1 (&0 (collatz n)))
    (λ n . (if (= n 1) 1 (&0 (collatz n))))
\end{Verbatim}

After testing the functions for a few small numbers (say, $n < 1000$), it is clear that the conjecture holds for them. To rewrite this tail-recursive function using iteration, it is required to use the alternate definition of \verb|while|. The second argument to \verb|while| can be an integer as demonstrated previously, however it can also be a function that returns a boolean value. The iteration will continue as long as the function returns a truthy value. The new function \verb|collatz-whl| will iterate the \verb|collatz| function until $n$ reaches 1:

\begin{Verbatim}
    --> defun collatz-whl (n) (while n $(/= 1) collatz)
    (λ n . (while n $(/= 1) collatz))
\end{Verbatim}

Another way to use \verb|while| is to omit the predicate argument and return a two element list of whether to continue iteration (true/false - yes/no) and the new value, however this approach is not demonstrated due to its lack of utility.

It might be of particular interest to determine the number of iterations and the numbers that have been reached in the process. This can be done using the \verb|partial-while| function which, as the name suggests, iterates a function and yields a list of partial results that have been obtained before the final result:

\begin{Verbatim}
    --> defun collatz-list (n) (partial-while n $(/= 1) collatz)
    (λ n . (partial-while n $(/= 1) collatz))
    --> collatz-list 15
    (46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1)
\end{Verbatim}

Another valuable comparison to be made between recursion, tail recursion and iteration is the implementation of Fibonacci numbers. Despite being implemented in KamilaLisp already as the function \verb|fib|, consider the following reimplementation:

\begin{Verbatim}
    --> defun fibr (n) (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2))))
    (λ n . (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2)))))
    --> fibr 5
    5
    --> fibr 10
    55
\end{Verbatim}

To derive a tail-recursive form of this function, it is necessary to use two accumulators:

\begin{Verbatim}
    --> defun fibt (n) ((
        ...    lambda (n a b) (if (= n 0) a (&0 (- n 1) b (+ a b)))) n 0 1)
    (λ n . ((lambda (n a b) (if (= n 0) a (&0/syn (- n 1) b (+ a b)))) n 0 1))
    --> fibt 10
    55
\end{Verbatim}

The iterative version of this function trivially follows, however, let's \textbf{assume} that it is \textit{not possible} to implement the iterative or tail-recursive version of this function - so the only implementation available a slow function that overflows the stack often. While in practice this is not the case, it is a good exercise to consider different ways in which the naive fibonacci function be improved.

Notice that the fibonacci function is rather expensive to compute, yet it takes just a number and returns just a number, so it is a good candidate for memoization. The memoization function \verb|memo| takes a function and returns a memoized version of it. The memoized version of the function will store the results of previous calls and return them if the same arguments are passed to the function again. This is a very useful technique to improve the performance of functions that are expensive to compute and are called with the same arguments repeatedly via a technique akin to dynamic tabulation of a function. The memoized version of the fibonacci function is, to no surprise, created as follows:

\begin{Verbatim}
    --> def fibr (memo fibr)
    memo$(λ n . (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2)))))
    --> fibr 10
    55
    --> fibr 20
    6765
    --> fibr 30
    832040
    --> fibr 50
    12586269025
    -->
\end{Verbatim}

The memoized version still has some issues (e.g. it will still overflow the stack if the cache is not big enough) but it is a good improvement over the original version. The built-in function \verb|fib| in KamilaLisp uses the Binet formula to compute the Fibonacci numbers, which is a much faster method than the naive recursive approach.

One nuance that needs to be pointed out is that in functions and lambda expressions, names are updated ad-hoc and usually looked up when needed to allow the programmer to utilise some interesting concepts such as mutual recursion. This has a few consequences, for instance:

\begin{Verbatim}
    --> defun f (x) (+ x a)
    (λ x . (+ x a))
    --> def a 5
    5
    --> f 5
    10
\end{Verbatim}

Another, more serious consequence is that the memoized version of the Fibonacci function will not quite work as expected if it is defined under a different name (e.g. as \verb|def fibm (memo fibr)|). The function \verb|fibm| will quickly return the result of \verb|fibm 10| if this value was explicitly asked for before, but not for \verb|fibm 11| - because the underlying function, \verb|fibr|, is still recursing and the memoized version of it is simply not being used.

\section{Exceptions}

Exceptions are the main error handling mechanism in KamilaLisp, unlike in Haskell/Rust (which usually make use of optional types) or OCaml (which supplies exceptions alongside optional types). Exceptions usually unwind the call stack and exhibit worse performance characteristics in the exceptional case, but they are much easier to use and are more familiar to programmers coming from other languages. Additionally, they exhibit better performance in the non-exceptional case.

Using the \verb|raise| function, the arithmetic average function could be rewritten to raise an exception if the list is empty:

\begin{Verbatim}
    --> defun avg (l) (if (same l 'nil) (raise "empty list") (/ (sum l) (tally l)))
    (λ l . (if (same l 'nil) (raise "empty list") (/ (sum l) (tally l))))
    --> avg '(1 2 3 4 5)
    3
    --> avg '()
    RaiseError thrown in thread 6b927fb:
        empty list
    at entity avg  1:1
    at (λ l . (if (same l 'nil) ...))  1:11
    at entity if  1:16
    at if primitive function
    at entity raise  1:34
    at raise primitive function
\end{Verbatim}

The exception raised by \verb|avg| and other kinds of exceptions (e.g. the one raised by \verb|/ 1 0|) can be caught using the \verb|try-catch| function. For instance, it can be employed to return the length of the error message instead of the average in the exceptional case, since the \verb|error| variable is bound in the catch block supplying the error handler with the exception's message:

\begin{Verbatim}
    --> try-catch (avg '()) (tally error)
    299
\end{Verbatim}

Of course, there is an extension to this system that allows the catch handler to distinguish different kinds of failures, as well as an extension to \verb|raise| that lets the programmer supply a custom exception type. An example of this follows:

\begin{Verbatim}
    --> defun frobnicate (x) (cond
    ...     ((< x 10) (raise 'domain_error "Input too large."))
    ...     ((> x 10) (raise 'domain_error "Input too small."))
    ...     ((= x 0) (raise 'arithmetic_error "Division by zero."))
    ...     ((= x 1) (raise 'logic_error "Unimplemented for x=1."))
    ...     (/ 1 x))
\end{Verbatim}

The invocation and subsequent handling of the exception is as follows:

\begin{Verbatim}
    --> defun stringify-type error-id (cond
    ...    ((same error-id 'domain_error) "Domain")
    ...    ((same error-id 'arithmetic_error) "Arithmetic")
    ...    ((same error-id 'logic_error) "Logic"))
    --> try-catch (frobnicate 0) (str:format
    ...    "Caught a {stringify-type error-id} error of length {tally error}.")
    Caught a Domain error of length 357.
\end{Verbatim}
