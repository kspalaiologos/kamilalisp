
\chapter*{Foreword}
\par KamilaLisp as a language has its origins in its previous iterations, v0.1 and MalbolgeLISP. The first iteration of MalbolgeLISP (v1.0) was released in August 2020 and had very few of the features that distinguish KamilaLisp today. The second iteration of MalbolgeLISP (v1.1) was released in July 2021 and was the subject of much attention due to its unusual choice of implementation language. The final MalbolgeLISP (v1.2) was released in September 2021, sharing many ideas and features with KamilaLisp. Unfortunately, the effort required to implement it continued to grow. The codebase was becoming increasingly disorganised and difficult to maintain. In addition, the implementation of new complicated features was increasingly difficult due to the choice of implementation language. The first version of KamilaLisp, a MalbolgeLISP-inspired Lisp dialect, appeared in December 2021, featuring lazy evaluation, sophisticated numerical and symbolic operations, and many original design choices borrowed from MalbolgeLISP. Progress on the language has stalled due to significant performance problems with the Java Virtual Machine, the overhead of lazy evaluation, and some questionable decisions made at the core of the interpreter. After realising this rather early, an effort to create a C++ rewrite of the original code base began towards the end of 2021, but was quickly abandoned due to problems with garbage collection, efficient memory management, and C++ lacking certain qualities that would otherwise make it a good language in which to implement an interpreter for KamilaLisp. In August 2022 I started working on KamilaLisp v0.2, a Java rewrite of the original codebase that does not have some of the problematic features of the previous versions. This book, in the hope of being useful to the determined reader who wants to learn about KamilaLisp, describes my experiences in implementing a complex language runtime using Java, and also describes the language itself. It is assumed that the reader has an elementary knowledge of functional programming or of the APL programming language.
