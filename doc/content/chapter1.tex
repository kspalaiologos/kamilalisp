
\chapter{Initial considerations}

This chapter discusses the basics of KamilaLisp. Throughout this book, the author will use the KamilaLisp interpreter to check and execute the declarations of a program one by one. The emphasis will be put on list processing and mathematical functions to form elementary understanding of the language.

\section{Programs and variables}

A KamilaLisp program is a sequence of declarations, which are executed in the order they are written. The first program presented in this book is shown below:

\begin{Verbatim}
    --> def a (+ (* 2 3) 2)
    8
    --> def b (* 5 a)
    40
\end{Verbatim}

It consists of two declarations. The first declaration binds the identifier a to the integer 8, and the second declaration binds the identifier b to the integer 40, which follows from the intuitive understanding of the arithmetic operations. To the reader not accustomed with Lisp-like syntax, every element of the syntax tree that would otherwise be implicitly grouped by a language with usual arithmetical precedence rules is explicitly grouped by parentheses to form a list. The resulting values of variables can be determined as follows:

\begin{Verbatim}
    --> ?a
    8
    --> ?b
    40
\end{Verbatim}

The question mark is a sign for the KamilaLisp interpreter not to evaluate the entire input as an expression, but rather, to query the value of what it refers to.

Every list besides the empty list (usually written as \verb|`()'| or alternatively \verb|nil|) has a \textit{head} defined as the first element of it. When a Lisp program is evaluated, the \textit{head} of the current list is assumed to be a callable value, while the rest of the list (also called the \textit{tail}) is assumed to be a list of arguments.

Because the list of arguments to a function (the \textit{tail}) is evaluated before its applied to the \textit{head}, a perceptive reader could point out a potential issue - \textit{How to introduce list literals in the code}? This question is indeed well-founded, since the list literal would be evaluated in order to pass it parameter to some callable object, hence the tail of the literal would be applied to its head, thus behaving undesirably and almost certainly raising an error. Every Lisp dialect addresses this issue in the same way using the quoting mechanism. Simply put, the quote prevents a list from being evaluated. To observe this behaviour, introduce two more functions called \verb|car| and \verb|cdr| to obtain respectively the \textit{head} and \textit{tail} of a list:

\begin{Verbatim}
    --> car '(1 2 3)
    1
    --> cdr '(1 2 3)
    (2 3)
\end{Verbatim}

KamilaLisp follows scoping rules familiar from other programming languages, such as Scheme or C++ - \textit{static scoping} (also called \textit{lexical scoping}), where an attempt is initially made to resolve a variable in the current scope. If this approach fails, the variable is resolved in the scope of its lexical ancestors until either the interpreter finds an environment where the variable is bound, or raises an error regarding an unbound variable. Additionally, variables may be \textit{shadowed}, as demonstrated below:

\begin{Verbatim}
    --> def my-list '(1 2 3)
    (1 2 3)
    --> car my-list
    1
    --> def my-list (cdr my-list)
    (2 3)
    --> car my-list
    2
\end{Verbatim}

However, it is not possible to shadow pre-defined variables and functions in the global scope:

\begin{Verbatim}
    --> def car 5
    RuntimeException thrown in thread 1dbd16a6:
            def can not shadow or redefine built-in bindings.
        at entity def  1:1
        at def primitive function
\end{Verbatim}

To fully exercise lexical scoping, the language needs to provide a way of binding names inside a specific block of code (unlike \textit{def} which binds names in the global scope). This can be accomplished in a variety of ways, the most straight-forward one being the \textit{let} construct. The \textit{let} construct binds a list of name/value pairs, and evaluates the body of the construct in the context of the newly created environment. The syntax of the \textit{let} construct is demonstrated by the following example:

\begin{Verbatim}
    --> def a 5
    5
    --> def b 6
    6
    --> + a b
    11
    --> let ((a 10) (b 15)) (+ a b)
    25
\end{Verbatim}

\section{Functions and lambda expressions}

Functions are the core component of KamilaLisp. They are first-class objects, which means that they can be passed as arguments to other functions, returned from functions, and assigned to variables. The syntax of a function declaration is as follows:

\begin{Verbatim}
    --> defun square (x) (* x x)
    (λ x . (* x x))
\end{Verbatim}

The function that has just been declared is called \verb|square|, and it takes one argument called \verb|x|. The body of the function is the expression \verb|(* x x)|. The function returns the value of their expression, which is simply the square of the argument. Notice that when defining a monadic function, a pair of parentheses can be omitted for brevity:

\begin{Verbatim}
    --> defun square x (* x x)
    (λ x . (* x x))
\end{Verbatim}

Since \verb|square| is now bound in the global scope, it can be applied to an argument. The code below binds the result of application of the number 5 to the function \verb|square| to the variable \verb|a|:

\begin{Verbatim}
    --> def a (square 5)
    25
\end{Verbatim}

Functions do not need to be named. They can be introduced in the code \textit{anonymously} using the \textit{lambda} construct, which opens up many new possibilities. For example, the declaration of the function \verb|square| can be rewritten as follows:

\begin{Verbatim}
    --> def square (lambda x (* x x))
    (λ x . (* x x))
\end{Verbatim}

Furthermore, multivariate lambda expressions could serve as a replacement for the \textit{let} construct:

\begin{Verbatim}
    --> let ((a 10) (b 15)) (+ a b)
    25
    --> (lambda (a b) (+ a b)) 10 15
    25
\end{Verbatim}

Since functions are first-class in KamilaLisp, it is now also possible to return them from functions and take them as arguments. The following example demonstrates these programming techniques using the \textit{lambda} construct:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
    --> ; Returns a string explaining the value of a function at point.
    --> defun explain (f x) (str:format "The value of f(x) for x={?x} is {f x}")
    (λ f x . (str:format "The value of f(x) for x={?x} is {f x}"))
    --> explain square 4.5
    The value of f(x) for x=4.5 is 20.25
\end{Verbatim}

When writing complex functions, it is of particular interest to keep the partial results obtained during the execution of the function. This can be achieved by cascading the \textit{let} construct, or using the \textit{let-seq} construct. The following examples implement a function that raises its first argument to the eigth power:

\begin{Verbatim}
    --> defun p8 x (let-seq (
    ...   (def y (* x x))
    ...   (def z (* y y))
    ...   (* z z)))
    (λ x . (let-seq ((def y (* x x)) (def z (* y y)) (* z z))))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x))) (let ((z (* y y))) (* z z)))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x)) (z (* y y))) (* z z))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
\end{Verbatim}

Notice that despite using \verb|def|, \verb|defun|, etc..., the \textit{let-seq} construct does not create any bindings in the global scope - the bindings are local to the block.

\section{Conditional expressions and comparisons}

The comparison operators in KamilaLisp don't differ significantly from the ones present in other, perhaps more orthodox programming languages (such as C). It is worth noting that equality is checked using the \verb|=| function, inequality is checked for using the \verb|/=| function, while the \verb|<=>| function is the so-called \textit{three way comparison} operator, which returns -1, 0 or 1 respectively if the first argument is less than, equal to, or greater than the second argument.

KamilaLisp provides a number of conditional expressions, which are used to control the flow of execution. The most basic one is the \textit{if} construct, which takes three arguments - a condition, an expression to be evaluated if the condition is true, and an expression to be evaluated if the condition is false. The syntax of the \textit{if} construct is demonstrated by the following example:

\begin{Verbatim}
    --> defun my-abs x (if (< x 0) (- x) x)
    (λ x . (if (< x 0) (- x) x))
    --> my-abs -5
    5
    --> my-abs 5
    5
    --> my-abs 0
    0
\end{Verbatim}

The \textit{if} construct is a special case of the \textit{cond} construct, which takes a list of pairs of conditions and expressions. The first condition that evaluates to true is used to evaluate the corresponding expression. The syntax of the \textit{cond} construct is demonstrated by the following reimplementation of the three-way comparison operator:

\begin{Verbatim}
    --> defun compare (x y) (cond ((< x y) -1) ((> x y) 1) (0))
    (λ x y . (cond ((< x y) -1) ((> x y) 1) (0)))
    --> compare 5 10
    -1
    --> compare 10 5
    1
    --> compare 5 5
    0
\end{Verbatim}

\section{Recursive functions}

Recursion is a powerful technique extensively used in functional programming. Its role in KamilaLisp is admittedly not as important as in other functional programming languages, since the language provides a number of other often more wieldy techniques for solving the same problems (e.g. using array programming). However, it is still worth mentioning that KamilaLisp provides a number of tools for writing recursive functions.

The following function implements the \textit{factorial} function in a recursive manner:

\begin{Verbatim}
    --> defun factorial (n) (if (= n 0) 1 (* n (factorial (- n 1))))
    (λ n . (if (= n 0) 1 (* n (factorial (- n 1)))))
    --> factorial 5
    120
\end{Verbatim}

Since KamilaLisp supports arbitrary precision integers, the factorial function can be applied to arbitrarily large numbers. However, at some point, this function will \textit{overflow its stack}, since the number of recursive calls will exceed the maximum stack size. This is a common problem in recursive functions, and it can be solved by using the \textit{tail recursion} technique. Tail recursion is a special case of recursion, where the recursive call is the last expression in the function body. In this case, the stack frame of the current function can be reused for the recursive call, which means that the stack will not grow indefinitely. To make use of this technique, the factorial function needs to be altered so that the recursive call is the last expression in the function body:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The factorial function defines a helper function that has an accumulator argument, which is used to store the intermediate results of the computation. The helper function is called recursively, and the accumulator argument is updated with the result of the multiplication. The \textit{let-seq} construct is used to define the helper function, so that it is not visible outside the factorial function. There is one more step to make this function tail-recursive: redefine the self-referential call to the helper function:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The self-referential call was replaced by \verb|&0|, which in simple terms is a reference to the current function. This is a special case of the \verb|&| operator, which is used to refer to functions by nesting level in the source code, akin to de Bruijn indices. The \verb|&0| operator refers to the current function, \verb|&1| refers to the function (anonymous or named) that is the lexical ancestor the current function, and so on. This way, the factorial function no longer errors when applied to large numbers, since the stack does not grow indefinitely:

\begin{Verbatim}
    --> factorial 1000
    402387260077093773543702433923003985719374864210714
    632543799910429938512398629020592044208486969404800
    ; [...]
    000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000
\end{Verbatim}
