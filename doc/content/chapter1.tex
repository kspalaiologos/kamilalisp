
\chapter{Initial considerations}

This chapter discusses the basics of KamilaLisp. Throughout this book, the author will use the KamilaLisp interpreter to check and execute the declarations of a program one by one. The emphasis will be put on list processing and mathematical functions to form elementary understanding of the language.

\section{Programs and variables}

A KamilaLisp program is a sequence of declarations, which are executed in the order they are written. The first program presented in this book is shown below:

\begin{Verbatim}
    --> def a (+ (* 2 3) 2)
    8
    --> def b (* 5 a)
    40
\end{Verbatim}

It consists of two declarations. The first declaration binds the identifier a to the integer 8, and the second declaration binds the identifier b to the integer 40, which follows from the intuitive understanding of the arithmetic operations. To the reader not accustomed with Lisp-like syntax, every element of the syntax tree that would otherwise be implicitly grouped by a language with usual arithmetical precedence rules is explicitly grouped by parentheses to form a list. The resulting values of variables can be determined as follows:

\begin{Verbatim}
    --> ?a
    8
    --> ?b
    40
\end{Verbatim}

The question mark is a sign for the KamilaLisp interpreter not to evaluate the entire input as an expression, but rather, to query the value of what it refers to.

Every list besides the empty list (usually written as \verb|`()'| or alternatively \verb|nil|) has a \textit{head} defined as the first element of it. When a Lisp program is evaluated, the \textit{head} of the current list is assumed to be a callable value, while the rest of the list (also called the \textit{tail}) is assumed to be a list of arguments.

Because the list of arguments to a function (the \textit{tail}) is evaluated before its applied to the \textit{head}, a perceptive reader could point out a potential issue - \textit{How to introduce list literals in the code}? This question is indeed well-founded, since the list literal would be evaluated in order to pass it parameter to some callable object, hence the tail of the literal would be applied to its head, thus behaving undesirably and almost certainly raising an error. Every Lisp dialect addresses this issue in the same way using the quoting mechanism. Simply put, the quote prevents a list from being evaluated. To observe this behaviour, introduce two more functions called \verb|car| and \verb|cdr| to obtain respectively the \textit{head} and \textit{tail} of a list:

\begin{Verbatim}
    --> car '(1 2 3)
    1
    --> cdr '(1 2 3)
    (2 3)
\end{Verbatim}

KamilaLisp follows scoping rules familiar from other programming languages, such as Scheme or C++ - \textit{static scoping} (also called \textit{lexical scoping}), where an attempt is initially made to resolve a variable in the current scope. If this approach fails, the variable is resolved in the scope of its lexical ancestors until either the interpreter finds an environment where the variable is bound, or raises an error regarding an unbound variable. Additionally, variables may be \textit{shadowed}, as demonstrated below:

\begin{Verbatim}
    --> def my-list '(1 2 3)
    (1 2 3)
    --> car my-list
    1
    --> def my-list (cdr my-list)
    (2 3)
    --> car my-list
    2
\end{Verbatim}

However, it is not possible to shadow pre-defined variables and functions in the global scope:

\begin{Verbatim}
    --> def car 5
    RuntimeException thrown in thread 1dbd16a6:
            def can not shadow or redefine built-in bindings.
        at entity def  1:1
        at def primitive function
\end{Verbatim}

To fully exercise lexical scoping, the language needs to provide a way of binding names inside a specific block of code (unlike \textit{def} which binds names in the global scope). This can be accomplished in a variety of ways, the most straight-forward one being the \textit{let} construct. The \textit{let} construct binds a list of name/value pairs, and evaluates the body of the construct in the context of the newly created environment. The syntax of the \textit{let} construct is demonstrated by the following example:

\begin{Verbatim}
    --> def a 5
    5
    --> def b 6
    6
    --> + a b
    11
    --> let ((a 10) (b 15)) (+ a b)
    25
\end{Verbatim}

\section{Functions and lambda expressions}

Functions are the core component of KamilaLisp. They are first-class objects, which means that they can be passed as arguments to other functions, returned from functions, and assigned to variables. The syntax of a function declaration is as follows:

\begin{Verbatim}
    --> defun square (x) (* x x)
    (λ x . (* x x))
\end{Verbatim}

The function that has just been declared is called \verb|square|, and it takes one argument called \verb|x|. The body of the function is the expression \verb|(* x x)|. The function returns the value of their expression, which is simply the square of the argument. Notice that when defining a monadic function, a pair of parentheses can be omitted for brevity:

\begin{Verbatim}
    --> defun square x (* x x)
    (λ x . (* x x))
\end{Verbatim}

Since \verb|square| is now bound in the global scope, it can be applied to an argument. The code below binds the result of application of the number 5 to the function \verb|square| to the variable \verb|a|:

\begin{Verbatim}
    --> def a (square 5)
    25
\end{Verbatim}

Functions do not need to be named. They can be introduced in the code \textit{anonymously} using the \textit{lambda} construct, which opens up many new possibilities. For example, the declaration of the function \verb|square| can be rewritten as follows:

\begin{Verbatim}
    --> def square (lambda x (* x x))
    (λ x . (* x x))
\end{Verbatim}

Furthermore, multivariate lambda expressions could serve as a replacement for the \textit{let} construct:

\begin{Verbatim}
    --> let ((a 10) (b 15)) (+ a b)
    25
    --> (lambda (a b) (+ a b)) 10 15
    25
\end{Verbatim}

Since functions are first-class in KamilaLisp, it is now also possible to return them from functions and take them as arguments. The following example demonstrates these programming techniques using the \textit{lambda} construct:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
    --> ; Returns a string explaining the value of a function at point.
    --> defun explain (f x) (str:format "The value of f(x) for x={?x} is {f x}")
    (λ f x . (str:format "The value of f(x) for x={?x} is {f x}"))
    --> explain square 4.5
    The value of f(x) for x=4.5 is 20.25
\end{Verbatim}

When writing complex functions, it is of particular interest to keep the partial results obtained during the execution of the function. This can be achieved by cascading the \textit{let} construct, or using the \textit{let-seq} construct. The following examples implement a function that raises its first argument to the eigth power:

\begin{Verbatim}
    --> defun p8 x (let-seq (
    ...   (def y (* x x))
    ...   (def z (* y y))
    ...   (* z z)))
    (λ x . (let-seq ((def y (* x x)) (def z (* y y)) (* z z))))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x))) (let ((z (* y y))) (* z z)))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
    --> defun p8 x (let ((y (* x x)) (z (* y y))) (* z z))
    (λ x . (let ((y (* x x)) (z (* y y))) (* z z)))
    --> p8 4
    65536
\end{Verbatim}

Notice that despite using \verb|def|, \verb|defun|, etc..., the \textit{let-seq} construct does not create any bindings in the global scope - the bindings are local to the block.

Function calls in KamilaLisp are performed using a \textit{call stack}. The call stack is a data structure inside of the interpreter that keeps track of the functions that are currently being executed. When a function is called, a new \textit{stack frame} is created and pushed onto the stack. When the function returns, the stack frame is popped from the stack - this way, the interpreter knows where to return to after the function yields a value. When an exception happens, the interpreter will present the user with a \textit{stack trace}, which is a list of functions that were executed before the exception was thrown, for example:

\begin{Verbatim}
    --> defun f x (/ 1 0) ; Oops! Division by zero!
    (λ x . (/ 1 0))
    --> defun g x (f x)
    (λ x . (f x))
    --> defun h x (g x)
    (λ x . (g x))
    --> h 10
    ArithmeticException thrown in thread 5e82df6a:
        Division by zero
    at entity h  1:1
    at (λ x . (g x))  1:9
    at entity g  1:12
    at (λ x . (f x))  1:9
    at entity f  1:12
    at (λ x . (/ 1 ...))  1:9
    at entity /  1:12
    at / primitive function
\end{Verbatim}

\section{Conditional expressions and comparisons}

The comparison operators in KamilaLisp don't differ significantly from the ones present in other, perhaps more orthodox programming languages (such as C). It is worth noting that equality is checked using the \verb|=| function, inequality is checked for using the \verb|/=| function, while the \verb|<=>| function is the so-called \textit{three way comparison} operator, which returns -1, 0 or 1 respectively if the first argument is less than, equal to, or greater than the second argument.

KamilaLisp provides a number of conditional expressions, which are used to control the flow of execution. The most basic one is the \textit{if} construct, which takes three arguments - a condition, an expression to be evaluated if the condition is true, and an expression to be evaluated if the condition is false. The syntax of the \textit{if} construct is demonstrated by the following example:

\begin{Verbatim}
    --> defun my-abs x (if (< x 0) (- x) x)
    (λ x . (if (< x 0) (- x) x))
    --> my-abs -5
    5
    --> my-abs 5
    5
    --> my-abs 0
    0
\end{Verbatim}

The \textit{if} construct is a special case of the \textit{cond} construct, which takes a list of pairs of conditions and expressions. The first condition that evaluates to true is used to evaluate the corresponding expression. The syntax of the \textit{cond} construct is demonstrated by the following reimplementation of the three-way comparison operator:

\begin{Verbatim}
    --> defun compare (x y) (cond ((< x y) -1) ((> x y) 1) (0))
    (λ x y . (cond ((< x y) -1) ((> x y) 1) (0)))
    --> compare 5 10
    -1
    --> compare 10 5
    1
    --> compare 5 5
    0
\end{Verbatim}

\section{Recursive functions}

Recursion is a powerful technique extensively used in functional programming. Its role in KamilaLisp is admittedly not as important as in other functional programming languages, since the language provides a number of other often more wieldy techniques for solving the same problems (e.g. using array programming). However, it is still worth mentioning that KamilaLisp provides a number of tools for writing recursive functions.

The following function implements the \textit{factorial} function in a recursive manner:

\begin{Verbatim}
    --> defun factorial (n) (if (= n 0) 1 (* n (factorial (- n 1))))
    (λ n . (if (= n 0) 1 (* n (factorial (- n 1)))))
    --> factorial 5
    120
\end{Verbatim}

Since KamilaLisp supports arbitrary precision integers, the factorial function can be applied to arbitrarily large numbers. However, at some point, this function will \textit{overflow its call stack}, meaning that the number of recursive calls will exceed the maximum call stack size. This is a common problem in recursive functions, and it can be solved by using the \textit{tail recursion} technique. Tail recursion is a special case of recursion, where the recursive call is the last expression in the function body. In this case, the stack frame of the current function can be reused for the recursive call, which means that the stack will not grow indefinitely. To make use of this technique, the factorial function needs to be altered so that the recursive call is the last expression in the function body:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (f' (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The factorial function defines a helper function that has an accumulator argument, which is used to store the intermediate results of the computation. The helper function is called recursively, and the accumulator argument is updated with the result of the multiplication. The \textit{let-seq} construct is used to define the helper function, so that it is not visible outside the factorial function. There is one more step to make this function tail-recursive: redefine the self-referential call to the helper function:

\begin{Verbatim}
    --> defun factorial (n) (let-seq (
    ...   (defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc))))
    ...   (f' n 1)))
    (λ n . (let-seq ((defun f' (n acc) (if (= n 0) acc (&0 (- n 1) (* n acc)))) (f' n 1))))
    --> factorial 5
    120
\end{Verbatim}

The self-referential call was replaced by \verb|&0|, which in simple terms is a reference to the current function. This is a special case of the \verb|&| operator, which is used to refer to functions by nesting level in the source code, akin to de Bruijn indices. The \verb|&0| operator refers to the current function, \verb|&1| refers to the function (anonymous or named) that is the lexical ancestor the current function, and so on. This way, the factorial function no longer errors when applied to large numbers, since the stack does not grow indefinitely:

\begin{Verbatim}
    --> factorial 1000
    402387260077093773543702433923003985719374864210714
    632543799910429938512398629020592044208486969404800
    ; [...]
    000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000
\end{Verbatim}

Another, closely related function to the factorial function that can be implemented using tail recursion is the power function. The following function implements the power function in a simple recursive manner:

\begin{Verbatim}
    --> defun power (x n) (if (= n 0) 1 (* x (power x (- n 1))))
    (λ x n . (if (= n 0) 1 (* x (power x (- n 1)))))
    --> power 2 10
    1024
\end{Verbatim}

Once again, the problem is that the stack will overflow when the power function is applied to large numbers. To prevent this and speed up the computation, the power function needs to be first transformed so that the recursive call is the last expression in the function body. Consider the following \textit{trace} of the power function applied to the arguments \verb|2| and \verb|4|:

\begin{Verbatim}
    --> power 2 4
    (* 2 (power 2 3))
    (* 2 (* 2 (power 2 2)))
    (* 2 (* 2 (* 2 (power 2 1))))
    (* 2 (* 2 (* 2 (* 2 (power 2 0)))))
    (* 2 (* 2 (* 2 2)))
    (* 2 (* 2 4))
    (* 2 8)
    16
\end{Verbatim}

After transforming the function to use an accumulator:

\begin{Verbatim}
    --> defun power (x n) (let-seq (
    ...   (defun f' (x n acc) (if (= n 0) acc (f' x (- n 1) (* x acc))))
    ...   (f' x n 1)))
\end{Verbatim}

When this implementation of the power function is applied to the same arguments as before, the following trace is produced:

\begin{Verbatim}
    --> power 2 4
    (f' 2 4 1)
    (f' 2 3 2)
    (f' 2 2 4)
    (f' 2 1 8)
    (f' 2 0 16)
    16
\end{Verbatim}

Notice, that the size of the expression \textit{does not grow}, hence the function could in theory be rewritten as a simple loop with bounded storage space requirements, a concept more familiar from imperative programming languages such as C or C++. The final improvement that needs to be applied is actually telling the interpreter to perform tail call optimisation in this case, using the self-referential call \verb|&0|:

\begin{Verbatim}
    --> defun power (x n) ((
    ...    lambda (x n acc) (if (= n 0) acc (&0 x (- n 1) (* x acc)))) x n 1)
    (λ x n . ((λ (x n acc) (if (= n 0) acc (&0/syn x (- n 1) (* x acc)))) x n 1))
    --> power 2 4
    16
\end{Verbatim}

\section{Function composition}

Function composition is a a common core concept in functional programming languages, an emphasis on which is placed in KamilaLisp. Using the \verb|@| operator, it is possible to compose two or more functions into a single function. An example follows:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> f 2
    4
    --> g 2
    3
    --> f@g 2
    6
\end{Verbatim}

The usefulness of function composition might be hard to appreciate at first. In the end, \verb|f@g x| $\Leftrightarrow$ \verb|f (g x)|, however, the function returned by the \verb|@| operator does not have to be immediately applied - it can be bound to a name and used later. Without the composition operator, it would be necessary to introduce a \textit{lambda} to achieve the same result as \verb|f@g| - that is, \verb|lambda x (f (g x))|. The difference between manually composing two functions to create a new function and using the \verb|@| operator is how they treat arguments. The \verb|@| operator variant of the same expression does not refer to the arguments of the composed functions (and thus does not manually relay an indeterminate amount of them to the innermost function), creating the basic building block for \textit{point-free programming}.

Of course, it is possible to compose arbitrarily many functions by using the \verb|@| operator multiple times. The following example demonstrates the composition of three functions:

\begin{Verbatim}
    --> defun f x (* x 2)
    (λ x . (* x 2))
    --> defun g x (+ x 1)
    (λ x . (+ x 1))
    --> defun h x (- x 3)
    (λ x . (- x 3))
    --> f@g@h 2
    0
\end{Verbatim}

Another form of function composition notoriously used in the APL family of programming languages is the so-called \textit{fork} (the \mu-recursive composition operator). Generally speaking, it is sometimes of special interest to preprocess the arguments using different functions (\textit{reductees}), and then funnel the results into a single function (\textit{reductor}). For instance, the arithmetic mean is defined as the quotient (\textit{reductor}) of the sum and length of a list (\textit{reductees}), while a palindrome is defined as a string for which the equality (\textit{reductor}) between it and its reverse (\textit{reductees}).

To implement a sum function using a fork, it is necessary to define a function that sums a list beforehand using the \verb|tally| function which returns the length of a list. A non-zero value is considered truthy, hence the following definition of the \textit{sum} function:

\begin{Verbatim}
    --> defun sum (l) (if (tally l) (+ (car l) (sum (cdr l))) 0)
    (λ l . (if (tally l) (+ (car l) (sum (cdr l))) 0))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

There are many alternative ways to implement it. One problem the reader may stumble upon is \verb|= 'nil 'nil| returning \verb|'nil|. This behaviour is reasoned by the fact that equality \textit{vectorises} over lists, meaning that equality is tested element-wise. To determine structural equality, it is advised to use the \verb|same| function. The following example demonstrates this behaviour:

\begin{Verbatim}
    --> = '(1 2 3) '(1 2 4)
    (1 1 0)
    --> same '(1 2 3) '(1 2 4)
    0
    --> same '(1 2 3) '(1 2 3)
    0
\end{Verbatim}

Hence arguing for a simpler implementation of the \textit{sum} function:
\begin{Verbatim}
    --> defun sum (l) (if (same l '()) 0 (+ (car l) (sum (cdr l))))
    (λ l . (if (same l '()) 0 (+ (car l) (sum (cdr l)))))
    --> sum '(1 6 2 3)
    12
\end{Verbatim}

The arithmetic mean function is thusly introduced as follows:

\begin{Verbatim}
    --> [/ sum tally] '(1 6 2 3 4)
    3.2
\end{Verbatim}

Of course, it could also be bound to a name without applying the fork instantaneously:

\begin{Verbatim}
    --> def avg [/ sum tally]
    [/ sum tally]
    --> avg '(1 6 2 3 4)
    3.2
\end{Verbatim}

The key merits of point-free programming are:

\begin{itemize}
    \item The code is more concise.
    \item The code is often more readable.
    \item The code is faster, because there is no need to allocate a stack frame.
    \item The code does not need to bind any names.
\end{itemize}

The lack of argument naming gives the point-free paradigm a reputation of being obtuse, hence the humorously used epithet "pointless style"\footnote{http://hdl.handle.net/1822/2869}. However, the point-free paradigm is not necessarily obscure. In fact, it is often more readable than the equivalent imperative code and favoured by many languages, such as Haskell, APL, J, PostScript, Forth, Factor, jq and the Unix shell\footnote{The pipe operator is essentially point-free function composition. The Unix shell has more interesting properties from a category theoretic perspective, due to its extensive use of monads. The pipe operator is an implementation of \verb|bind|, \verb|cat| is in reality monadic \verb|return|. Moreover, a pair of these operations, adding \verb|<| and \verb|>|, satisfy the monadic laws - \verb$cat f | cmd$ is the same as \verb|cmd <f| (left-hand identity); \verb$cmd | cat$ is the same as \verb|cmd| (right-hand identity); \verb$c1 | (c2 | c3)$ is the same as \verb$(c1 | c2) | c3$.}.

\section{Partial application and \texorpdfstring{$\mu$}{mu}-recursive functions}

Most functional programming languages, such as OCaml and Haskell automatically \textit{curry} functions by default, that is, allow applying functions to fewer arguments than they are defined to take. This is a useful feature, because it allows for the creation of new functions by binding some of the arguments of a function to a value. This mechanism is called \textit{partial application}. KamilaLisp supports partial application of functions but it does not happen by default, since unlike OCaml and Haskell, KamilaLisp supports variadic functions. Recall the following example given earlier in the book:

\begin{Verbatim}
    --> ; Returns a function that adds a given number to its argument.
    --> ; The technique demonstrated is often called "currying".
    --> defun make-adder (x) (lambda y (+ x y))
    (λ x . (λ y . (+ x y)))
    --> def add-5 (make-adder 5)
    (λ y . (+ 5 y))
    --> add-5 10
    15
\end{Verbatim}

Using partial application, the example can be rewritten as follows:

\begin{Verbatim}
    --> defun add-x n $(+ n)
    (λ n . $(+ n))
    --> def add-5 (add-x 5)
    $(+ n)
    --> add-5 6
    11
\end{Verbatim}

Partial application is particularly useful in conjunction with various kinds of function composition, as it allows for the vast majority of functions that are defined in terms of other functions to be defined in a point-free manner. Another example would be a function that returns the remainder of a number when divided by two.

\begin{Verbatim}
    --> defun mod-2 (n) (mod n 2)
    (λ n . (mod n 2))
    --> mod-2 10
    0
    --> mod-2 11
    1
\end{Verbatim}

It is not immediately clear how to define this function in a point-free manner, since partial application will apply the arguments in order as given, and the argument that needs to be partially applied here is actually the \textit{second} argument to \verb|mod|. This problem can be solved in a two ways - the first one is to use the commute operator \verb|^| which reverses the argument order to a function:

\begin{Verbatim}
    --> def mod-2 $(^mod 2)
    $['^mod, '2]
    --> mod-2 5
    1
    --> mod-2 6
    0
\end{Verbatim}

Another, perhaps more elegant solution is to use partial application placeholders:

\begin{Verbatim}
    --> def mod-2 $(mod _ 2)
    $['mod, _, '2]
    --> mod-2 5
    1
    --> mod-2 6
    0
\end{Verbatim}

This way, the \verb|_| placeholder indicates that the first argument given to the resulting function should be put in its place. The placeholder can be used multiple times and it is required that all placeholder slots are filled when applying the already partially applied function.

Variadic functions were briefly mentioned earlier in the book. Simply speaking, they are functions that take an arbitrary number of arguments. \verb|+| is a good example of a variadic function, since when applied to more than two arguments, it just sums everything:

\begin{Verbatim}
    --> + 1 2 3 4 5
    15
\end{Verbatim}

It is possible to define custom variadic functions in KamilaLisp using special argument syntax. To recall, \verb|lambda (x y) (code)| takes two arguments - \textit{x} and \textit{y}. This function can be made variadic by prepending the \textit{last argument} with an ellipsis - \verb|lambda (x ...xs) (code)|. The last argument is bound to a list of all the remaining arguments. This has an interesting property: while the aforementioned function takes \textit{at least} one argument (because \verb|...xs| can be empty), it can be modified to take any amount of arguments, even zero - \verb|lambda ...xs (code)|. To demonstrate this behaviour, the following function will obtain the arithmetic average of all its arguments, but will refuse to be called with zero arguments:

\begin{Verbatim}
    --> defun avg (x ...xs) (/ (+ x (sum ...xs)) (+ 1 (tally ...xs)))
    (λ x ...xs . (/ (+ x (sum ...xs)) (+ 1 (tally ...xs))))
    --> avg 1 6 2 3 4
    3.2
    --> avg 5
    5
    --> avg
    TypeError thrown in thread 15eb5ee5:
            Expected at least 1 arguments to `(λ x ...xs . (/ (+ x (sum ...xs)) ...))'.
        at entity avg  1:1
        at (λ x ...xs . (/ (+ x (sum ...xs)) ...))  1:11
\end{Verbatim}

Equipped with the power of variadic functions and recursion, the next natural step is to define $\mu$-recursive functions. Consider the following \textit{basic} $\mu$-recursive functions:

\begin{itemize}
    \item For all natural numbers $i, k$ where $0 \le i \le k$, the projection function (sometimes also called the identity function when $i=0$) is defined as $P_i^k(x_0, \dots, x_k)=x_i$. The projection function is a built-in operator in KamilaLisp, where \verb|#a| is equivalent to $P_a^k$.
    \item For each natural $n$ and $k$, the constant function $C_n^k$ is defined as $C_n^k(x_0, \dots, x_k) = x_n$. This is easily implemented using the previously discussed projection function as \verb|$(#0 n)|.
    \item For each natural $n$, the successor function $S_n$ is defined as $S_n(x) = x + 1$. This is easily implemented using just function composition - \verb|$(+ 1)|.
\end{itemize}

The $\mu$-recursive composition operator (also called the substitution operator) defined for an $m$-ary function $h(x_0, \dots, x_m)$ and exactly $m$ $n$-ary functions $g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n)$ as $h\circ(g_0, \dots, g_m) = f$ where $f(x_0, \dots, x_n) = h(g_0(x_0, \dots, x_n), \dots, g_m(x_0, \dots, x_n))$. This definition is essentially equivalent to KamilaLisp \textit{forks}\footnote{A general version of APL 3-trains; https://aplwiki.com/wiki/Train\#3-trains} - \verb|[h g_0 ... g_m] x_0 ... x_k|.

The $\mu$-recursive primitive recursion operator $\rho(g,h)=f$ for $k$-ary function $g(x_0,\dots,x_k)$, $k+2$-ary function $h(y,z,x_0,\dots,x_k)$ and $k+1$-ary function $f$ yields the following piecewise function:

\begin{equation*}
f(a,x_0,\dots,x_k)=
    \begin{cases}
        g(x_0,\dots,x_k) & \text{if } x = 0\\
        h(a-1,f(a,x_0,\dots,x_k),x_0,\dots,x_k) & \text{if } x \ne 0
    \end{cases}
\end{equation*}

The KamilaLisp implementation of this concept is slightly more involved, requiring the \verb|lift| function to apply a function on a existing variadic parameter pack:

\begin{Verbatim}
    --> defun mu-prim-rec (g h) (
    ...    lambda (a ...xs) (
    ...        if (= a 0)
    ...            (lift g ...xs)
    ...            (lift $(h (- a 1) (lift $(mu-prim-rec g h) ...xs)) ...xs)))
\end{Verbatim}

The $\mu$-recursive \textit{minimization} operator is less demanding to implement. Intuitively, minimisation seeks, beginning the search from 0 and proceeding upwards, the smallest argument that causes the function to return zero; if there is no such argument, of if one encounters an argument for which f is not defined, then the search never terminates, and is not defined for the argument.

\begin{Verbatim}
    --> defun mu-min f (lambda ...xs (let-seq (
    ...    (defun mu-min-iter i (if (lift f ...xs) (&0 (S i)) i))
    ...    (mu-min-iter 0))))
\end{Verbatim}

\section{Iteration}

Given a function $f$, the $n$-fold application of $f$ to $x$ is usually denoted in mathematics as $f^n(x)$. For instance, $f^0(x) = x$, $f^1(x) = f(x)$, and $f^2(x) = f(f(x))$. More generally, a recursive relation can be defined as $f^k(x) = f(f^k-1(x))$ for $k \ge 1$. Given \textit{an iteration} of a function $f^n(x)$, the function $f$ is called the \textit{step function}, $n$ is called the order of iteration and $x$ is called the \textit{starting value}. In KamilaLisp, iteration is introduced using the \verb|while| higher order function which, in the presently most useful form to the mathematical definition, takes three arguments - the starting value, the order of iteration and the step function.

Consider the successor function \verb|defun s x (+ x 1)|. To provide a basic example, addition of two numbers \verb|+ a b| can be implemented as an iteration of order $b$ of the successor function \verb|s| with the initial value $a$:

\begin{Verbatim}
    --> defun add (a b) (while a b $(+ 1))
    (λ a b . (while a b $(+ 1)))
    --> add 3 4
    7
\end{Verbatim}

Recall the power function and its previously discussed, tail-recursive definition:

\begin{Verbatim}
    --> defun power (x n) ((
    ...    lambda (x n acc) (if (= n 0) acc (&0 x (- n 1) (* x acc)))) x n 1)
    (λ x n . ((λ (x n acc) (if (= n 0) acc (&0/syn x (- n 1) (* x acc)))) x n 1))
\end{Verbatim}

Since tail recursion is essentially equivalent to iteration, the power function can be implemented as an iteration of order $n-1$ of the multiplication function \verb|*| with the initial value $x$:

\begin{Verbatim}
    --> defun power (x n) (while x (- n 1) $(* x))
    (λ x n . (while x (- n 1) $(* x)))
    --> power 2 4
    16
\end{Verbatim}

Iteration using \verb|while| and other higher order functions is described later on in the book. As a tool, iteration is more suitable to certain problems over recursive (functional) or array programming approaches\footnote{For instance, computing the \textit{Convex Hull} using the Graham scan algorithm, which has better asymptotic complexity than the more naive Jarvis scan as easily implemented in array fashion}.

Of course, iteration with a fixed number of steps is the simplest form of iteration that covers many usages of the \verb|for| loop from other more orthodox languages, such as C. However, iteration is often conditional and depends on some particular predicate. Consider the Collatz conjecture, one of the most famous unsolved problems in mathematics. The conjecture asks whether iterating this function as many times as needed will eventually reach the number 1:

\begin{equation*}
    f(n)={\begin{cases}{\frac {n}{2}}&{\text{if }}n\equiv 0{\pmod {2}}\\[4px]3n+1&{\text{if }}n\equiv 1{\pmod {2}}.\end{cases}}
\end{equation*}

Providing a formal proof of the Collatz conjecture is beyond the scope of this book, but KamilaLisp makes it easy to test the conjecture for a finite set of numbers\footnote{Even though the Collatz conjecture has been proven using computers for extremely large values of $n$, this is not enough evidence to claim that the Collatz function is likely true - consider the Polyá conjecture, for which the initial \textit{disproof by counterexample} quoted a number estimated to be around $n = 1.845 \times 10^{361}$}. Start by implementing the function $f$ in code and then use it in a recursive approach and a tail-recursive approach:

\begin{Verbatim}
    --> defun collatz (n) (if (= (mod n 2) 0) (/ n 2) (+ (* 3 n) 1))
    (λ n . (if (= (mod n 2) 0) (/ n 2) (+ (* 3 n) 1)))
    --> defun collatz-rec (n) (if (= n 1) 1 (collatz-rec (collatz n)))
    (λ n . (if (= n 1) 1 (collatz-iter (collatz n))))
    --> defun collatz-tail (n) (if (= n 1) 1 (&0 (collatz n)))
    (λ n . (if (= n 1) 1 (&0 (collatz n))))
\end{Verbatim}

After testing the functions for a few small numbers (say, $n < 1000$), it is clear that the conjecture holds for them. To rewrite this tail-recursive function using iteration, it is required to use the alternate definition of \verb|while|. The second argument to \verb|while| can be an integer as demonstrated previously, however, it can also be a function that returns a boolean value. The iteration will continue as long as the function returns true. The new function \verb|collatz-whl| will iterate the \verb|collatz| function until $n$ reaches 1:

\begin{Verbatim}
    --> defun collatz-whl (n) (while n $(/= 1) collatz)
    (λ n . (while n $(/= 1) collatz))
\end{Verbatim}

Another possible way to use \verb|while| is to omit the predicate argument and return a two element list of whether to continue iteration (true/false) and the new value, however this approach is not demonstrated due to its lack of utility. It might be of particular interest to determine the number of iterations and the numbers that have been reached in the process. This can be done using the \verb|partial-while| function which, as the name suggests, iterates a function and yields a list of partial results that have been obtained before the final result:

\begin{Verbatim}
    --> defun collatz-list (n) (partial-while n $(/= 1) collatz)
    (λ n . (partial-while n $(/= 1) collatz))
    --> collatz-list 15
    (46 23 70 35 106 53 160 80 40 20 10 5 16 8 4 2 1)
\end{Verbatim}

Another valuable comparison to be made between recursion, tail recursion and iteration is the implementation of fibonacci numbers. Despite being implemented in KamilaLisp already as the function \verb|fib|, consider the following reimplementation:

\begin{Verbatim}
    --> defun fibr (n) (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2))))
    (λ n . (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2)))))
    --> fibr 5
    5
    --> fibr 10
    55
\end{Verbatim}

To derive a tail-recursive form of this function, it is necessary to use two accumulators:

\begin{Verbatim}
    --> defun fibt (n) ((
        ...    lambda (n a b) (if (= n 0) a (&0 (- n 1) b (+ a b)))) n 0 1)
    (λ n . ((lambda (n a b) (if (= n 0) a (&0/syn (- n 1) b (+ a b)))) n 0 1))
    --> fibt 10
    55
\end{Verbatim}

The iterative version of this function trivially follows, however, let's \textbf{assume} that it is \textit{not possible} to implement the iterative or tail-recursive version of this function - so the only implementation available a slow function that overflows the stack often. While in practice this is not the case, it is a good exercise to consider different ways in which the naive fibonacci function be improved.

Notice that the fibonacci function is considerably expensive to compute, yet it takes just a number and returns just a number, so it is a good candidate for memoization. The memoization function \verb|memo| takes a function and returns a memoized version of it. The memoized version of the function will store the results of previous calls and return them if the same arguments are passed to the function again. This is a very useful technique to improve the performance of functions that are expensive to compute and are called with the same arguments repeatedly via a technique akin to dynamic tabulation of a function. The memoized version of the fibonacci function is, to no surprise, created as follows:

\begin{Verbatim}
    --> def fibr (memo fibr)
    memo$(λ n . (if (< n 2) n (+ (fibr (- n 1)) (fibr (- n 2)))))
    --> fibr 10
    55
    --> fibr 20
    6765
    --> fibr 30
    832040
    --> fibr 50
    12586269025
    -->
\end{Verbatim}

The memoized version still has some problems (e.g. it will still overflow the stack if the cache is not big enough) but it is a good improvement over the original version. The built-in function \verb|fib| in KamilaLisp uses the Binet formula to compute the fibonacci numbers, which is a much faster method than the naive recursive approach.

One nuisance that needs to be pointed out is that in functions and lambda expressions, names are updated ad-hoc and usually looked up when needed to allow the programmer to utilise some interesting concepts such as mutual recursion. This has a few consequences, for instance:

\begin{Verbatim}
    --> defun f (x) (+ x a)
    (λ x . (+ x a))
    --> def a 5
    5
    --> f 5
    10
\end{Verbatim}

Another much more serious consequence is that the memoized version of the fibonacci function will not quite work as expected if it is defined under a different name (e.g. as \verb|def fibm (memo fibr)|). The function \verb|fibm| will quickly return the result of \verb|fibm 10| if this value was explicitly asked for before, but not for \verb|fibm 11| - because the underlying function, \verb|fibr|, is still recursing and the memoized version of it is simply not being used.

\section{Exceptions}

Exceptions are the main error handling mechanism in KamilaLisp, unlike in Haskell/Rust (which usually make use of optional types) or OCaml (which supplies exceptions alongside optional types). Exceptions usually propagate the stack and exhibit worse performance characteristics in the exceptional case, but they are much easier to use and are more familiar to programmers coming from other languages. Additionally, they exhibit better performance in the non-exceptional case.

Using the \verb|raise| function, the arithmetic average function could be rewritten to throw an exception if the list is empty:

\begin{Verbatim}
    --> defun avg (l) (if (same l 'nil) (raise "empty list") (/ (sum l) (tally l)))
    (λ l . (if (same l 'nil) (raise "empty list") (/ (sum l) (tally l))))
    --> avg '(1 2 3 4 5)
    3
    --> avg '()
    RaiseError thrown in thread 6b927fb:
        empty list
    at entity avg  1:1
    at (λ l . (if (same l 'nil) ...))  1:11
    at entity if  1:16
    at if primitive function
    at entity raise  1:34
    at raise primitive function
\end{Verbatim}

The exception thrown by \verb|avg| and other kinds of exceptions (e.g. the one thrown by \verb|/ 1 0|) can be caught using the \verb|try-catch| function. For instance, it can be employed to return the length of the error message instead of the average in the exceptional case:

\begin{Verbatim}
    --> try-catch (avg '()) (tally error)
    299
\end{Verbatim}
